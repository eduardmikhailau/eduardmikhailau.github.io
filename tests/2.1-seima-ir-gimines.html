<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>2.1 Šeima ir giminės — Practice Tests</title>
    <script src="https://cdn.tailwindcss.com"></script>
  </head>
  <body class="min-h-screen bg-slate-50 text-slate-900">
    <div class="mx-auto flex min-h-screen max-w-3xl flex-col px-4 py-6">
      <header class="mb-6 text-center">
        <h1 class="text-2xl font-semibold sm:text-3xl">2.1 Šeima ir giminės — Practice Tests</h1>
      </header>

      <main class="flex-1">
        <section id="start-screen" class="space-y-4 rounded-2xl bg-white p-6 shadow-sm">
          <h2 class="text-xl font-semibold">Ready to start?</h2>
          <p class="text-sm text-slate-600">
            Each run randomizes question order and answer options. You will see immediate feedback and
            a summary at the end.
          </p>
          <p id="resume-note" class="hidden text-xs text-slate-500">Saved progress detected.</p>
          <p id="version-note" class="hidden text-xs text-amber-600">
            This test was updated. Continue to use the saved version or start a new one.
          </p>
          <button
            id="start-button"
            class="w-full rounded-xl bg-indigo-600 px-4 py-3 text-sm font-semibold text-white shadow-sm transition hover:bg-indigo-500"
          >
            Start Tests
          </button>
          <button
            id="start-new-button"
            class="hidden w-full rounded-xl border border-slate-200 bg-white px-4 py-3 text-sm font-semibold text-slate-700 shadow-sm transition hover:bg-slate-50"
          >
            Start New Version
          </button>
        </section>

        <section id="test-screen" class="hidden space-y-6 pb-28">
          <div class="rounded-2xl bg-white p-5 shadow-sm">
            <div class="flex flex-wrap items-center justify-between gap-3">
              <div>
                <p id="test-title" class="text-lg font-semibold"></p>
                <p id="test-progress" class="text-sm text-slate-600"></p>
              </div>
              <div class="flex items-center gap-3 text-right">
                <div>
                  <p class="text-sm text-slate-500">Overall progress</p>
                  <p id="overall-progress" class="text-base font-semibold"></p>
                </div>
                <button
                  id="reset-button"
                  class="inline-flex h-9 w-9 items-center justify-center rounded-full border border-slate-200 bg-white text-slate-500 shadow-sm transition hover:bg-slate-50"
                  type="button"
                  title="Restart test"
                  aria-label="Restart test"
                >
                  <svg class="h-4 w-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M3 12a9 9 0 1 0 3-6.7" />
                    <path d="M3 4v6h6" />
                  </svg>
                </button>
              </div>
            </div>
          </div>

          <div class="rounded-2xl bg-white p-6 shadow-sm">
            <div id="question-block" class="space-y-4">
              <div class="flex items-start justify-between gap-3">
                <p id="question-label" class="text-sm font-semibold uppercase tracking-wide text-indigo-600"></p>
                <button
                  id="save-question"
                  class="inline-flex h-9 w-9 items-center justify-center rounded-full border border-slate-200 text-slate-500 shadow-sm transition hover:bg-slate-50"
                  type="button"
                  aria-label="Save question"
                  title="Save question"
                  aria-pressed="false"
                >
                  <svg class="h-4 w-4" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                    <path d="M19 21H5a2 2 0 0 1-2-2V7.5A2.5 2.5 0 0 1 5.5 5H17l4 4v10a2 2 0 0 1-2 2z"/>
                    <path d="M7 21V12h10v9"/>
                    <path d="M7 5v4h8"/>
                  </svg>
                </button>
              </div>
              <p id="question-text" class="text-xl font-semibold"></p>
              <p id="question-subtitle" class="text-sm text-slate-600"></p>
            </div>

            <div id="answer-block" class="mt-5 space-y-3"></div>

            <div id="feedback" class="mt-4 hidden rounded-xl border px-4 py-3 text-sm"></div>
          </div>

          <div id="next-panel" class="fixed inset-x-0 bottom-0 z-10 hidden border-t border-slate-200 bg-white/95 backdrop-blur">
            <div class="mx-auto max-w-3xl px-4 py-4">
              <button
                id="next-button"
                class="w-full rounded-xl bg-indigo-600 px-4 py-3 text-sm font-semibold text-white shadow-sm transition hover:bg-indigo-500"
              >
                Next
              </button>
            </div>
          </div>
        </section>

        <section id="summary-screen" class="hidden space-y-5 rounded-2xl bg-white p-6 shadow-sm">
          <div>
            <h2 class="text-xl font-semibold">Your progress summary</h2>
            <p id="summary-total" class="text-sm text-slate-600"></p>
          </div>
          <div id="summary-table" class="space-y-3"></div>
          <div id="saved-questions-section" class="space-y-3">
            <div class="flex items-center justify-between">
              <h3 class="text-base font-semibold">Saved questions</h3>
              <button
                id="clear-saved-questions"
                class="text-xs font-semibold text-slate-500 transition hover:text-slate-700"
                type="button"
              >
                Clear
              </button>
            </div>
            <p id="saved-questions-empty" class="text-sm text-slate-500">No saved questions yet.</p>
            <div id="saved-questions-list" class="space-y-3"></div>
          </div>
          <button
            id="restart-button"
            class="w-full rounded-xl bg-indigo-600 px-4 py-3 text-sm font-semibold text-white shadow-sm transition hover:bg-indigo-500"
          >
            Restart Tests
          </button>
        </section>
      </main>

      <footer class="mt-8 text-center text-xs text-slate-500">
      </footer>
    </div>

    <script>

      const wordSet = {
        topic: "Šeima ir giminės",
        words: [
          { id: "seima", lt: "šeima", ru: "семья" },
          { id: "tevai", lt: "tėvai", ru: "родители" },
          { id: "tevas", lt: "tėvas", ru: "отец (нейтр./официально)" },
          { id: "tetis", lt: "tėtis", ru: "папа, папочка (разг.)" },
          { id: "motina", lt: "motina", ru: "мать (нейтр./официально)" },
          { id: "mama", lt: "mama", ru: "мама, мамочка (разг.)" },
          { id: "sunus", lt: "sūnus", ru: "сын" },
          { id: "dukte", lt: "duktė", ru: "дочь" },
          { id: "brolis", lt: "brolis", ru: "брат" },
          { id: "sesuo", lt: "sesuo", ru: "сестра" },
          { id: "vaikas", lt: "vaikas", ru: "ребенок" },
          { id: "kudikis", lt: "kūdikis", ru: "младенец" },
          { id: "vyras", lt: "vyras", ru: "муж" },
          { id: "zmona", lt: "žmona", ru: "жена" },
          { id: "senelis", lt: "senelis", ru: "дедушка" },
          { id: "senele", lt: "senelė", ru: "бабушка (нейтр.)" },
          { id: "mociute", lt: "močiutė", ru: "бабуля, бабушка (ласк.)" },
          { id: "prosenelis", lt: "prosenelis", ru: "прадедушка" },
          { id: "prosenele", lt: "prosenelė", ru: "прабабушка" },
          { id: "anukas_anuke", lt: "anūkas, anūkė", ru: "внук, внучка" },
          { id: "gimines", lt: "giminės", ru: "родственники" },
          { id: "dede", lt: "dėdė", ru: "дядя" },
          { id: "teta", lt: "teta", ru: "тётя" },
          { id: "pusbrolis", lt: "pusbrolis", ru: "двоюродный брат" },
          { id: "pussesere", lt: "pusseserė", ru: "двоюродная сестра" },
          { id: "vedes", lt: "vedęs", ru: "женат" },
          { id: "istekejusi", lt: "ištekėjusi", ru: "замужем" },
          { id: "issiskyres", lt: "išsiskyręs", ru: "разведенный" },
          { id: "issiskyrusi", lt: "išsiskyrusi", ru: "разведенная" },
          { id: "mires", lt: "miręs", ru: "умерший" },
          { id: "mirusi", lt: "mirusi", ru: "умершая" }
        ]
      };

                        const gapFillVariants = {
        "seima": [
          {
            "sentence": "Mano ___ gyvena Vilniuje.",
            "translationRu": "Моя семья живет в Вильнюсе.",
            "answer": "šeima",
            "options": ["šeima", "žmona", "motina"]
          },
          {
            "sentence": "Per šventes susirenka visa ___.",
            "translationRu": "На праздники собирается вся семья.",
            "answer": "šeima",
            "options": ["šeima", "žmona", "motina"]
          },
          {
            "sentence": "___ kartu vakarieniauja.",
            "translationRu": "Семья вместе ужинает.",
            "answer": "šeima",
            "options": ["šeima", "žmona", "motina"]
          }
        ],
        "tevai": [
          {
            "sentence": "Mano ___ gyvena Kaune.",
            "translationRu": "Мои родители живут в Каунасе.",
            "answer": "tėvai",
            "options": ["tėvai", "giminės", "vaikai"]
          },
          {
            "sentence": "Aš dažnai lankau savo ___.",
            "translationRu": "Я часто навещаю своих родителей.",
            "answer": "tėvus",
            "options": ["tėvus", "gimines", "vaikus"]
          },
          {
            "sentence": "Mano ___ dirba kartu.",
            "translationRu": "Мои родители работают вместе.",
            "answer": "tėvai",
            "options": ["tėvai", "giminės", "vaikai"]
          }
        ],
        "tevas": [
          {
            "sentence": "Mano ___ dirba ligoninėje.",
            "translationRu": "Мой отец работает в больнице.",
            "answer": "tėvas",
            "options": ["tėvas", "dėdė", "brolis"]
          },
          {
            "sentence": "Aš matau savo ___.",
            "translationRu": "Я вижу своего отца.",
            "answer": "tėvą",
            "options": ["tėvą", "dėdę", "brolį"]
          },
          {
            "sentence": "Be ___ patarimo man sunku.",
            "translationRu": "Без совета отца мне трудно.",
            "answer": "tėvo",
            "options": ["tėvo", "dėdės", "brolio"]
          }
        ],
        "tetis": [
          {
            "sentence": "Mano ___ mėgsta žvejoti.",
            "translationRu": "Мой папа любит рыбалку.",
            "answer": "tėtis",
            "options": ["tėtis", "dėdė", "brolis"]
          },
          {
            "sentence": "Ryte ___ geria kavą.",
            "translationRu": "Утром папа пьет кофе.",
            "answer": "tėtis",
            "options": ["tėtis", "dėdė", "brolis"]
          },
          {
            "sentence": "Aš apkabinu ___.",
            "translationRu": "Я обнимаю папу.",
            "answer": "tėtį",
            "options": ["tėtį", "dėdę", "brolį"]
          }
        ],
        "motina": [
          {
            "sentence": "Mano ___ gyvena kitame mieste.",
            "translationRu": "Моя мать живет в другом городе.",
            "answer": "motina",
            "options": ["motina", "teta", "žmona"]
          },
          {
            "sentence": "Aš kalbu su savo ___.",
            "translationRu": "Я разговариваю со своей матерью.",
            "answer": "motina",
            "options": ["motina", "teta", "žmona"]
          },
          {
            "sentence": "Be ___ pagalbos man sunku.",
            "translationRu": "Без помощи матери мне трудно.",
            "answer": "motinos",
            "options": ["motinos", "tetos", "žmonos"]
          }
        ],
        "mama": [
          {
            "sentence": "___ gamina vakarienę.",
            "translationRu": "Мама готовит ужин.",
            "answer": "mama",
            "options": ["mama", "sesuo", "žmona"]
          },
          {
            "sentence": "Aš skambinu ___.",
            "translationRu": "Я звоню маме.",
            "answer": "mamai",
            "options": ["mamai", "seseriai", "tetai"]
          },
          {
            "sentence": "Aš apkabinu ___.",
            "translationRu": "Я обнимаю маму.",
            "answer": "mamą",
            "options": ["mamą", "seserį", "tetą"]
          }
        ],
        "sunus": [
          {
            "sentence": "Jų ___ lanko mokyklą.",
            "translationRu": "Их сын ходит в школу.",
            "answer": "sūnus",
            "options": ["sūnus", "brolis", "anūkas"]
          },
          {
            "sentence": "Aš matau ___.",
            "translationRu": "Я вижу сына.",
            "answer": "sūnų",
            "options": ["sūnų", "brolį", "anūką"]
          },
          {
            "sentence": "Mano ___ žaidžia futbolą.",
            "translationRu": "Мой сын играет в футбол.",
            "answer": "sūnus",
            "options": ["sūnus", "brolis", "anūkas"]
          }
        ],
        "dukte": [
          {
            "sentence": "Jų ___ piešia.",
            "translationRu": "Их дочь рисует.",
            "answer": "duktė",
            "options": ["duktė", "sesuo", "anūkė"]
          },
          {
            "sentence": "Aš apkabinu ___.",
            "translationRu": "Я обнимаю дочь.",
            "answer": "duktę",
            "options": ["duktę", "seserį", "anūkę"]
          },
          {
            "sentence": "Mano ___ mokosi universitete.",
            "translationRu": "Моя дочь учится в университете.",
            "answer": "duktė",
            "options": ["duktė", "sesuo", "anūkė"]
          }
        ],
        "brolis": [
          {
            "sentence": "Mano ___ gyvena Klaipėdoje.",
            "translationRu": "Мой брат живет в Клайпеде.",
            "answer": "brolis",
            "options": ["brolis", "tėvas", "dėdė"]
          },
          {
            "sentence": "Aš laukiu ___.",
            "translationRu": "Я жду брата.",
            "answer": "brolio",
            "options": ["brolio", "tėvo", "dėdės"]
          },
          {
            "sentence": "Aš matau ___.",
            "translationRu": "Я вижу брата.",
            "answer": "brolį",
            "options": ["brolį", "tėvą", "dėdę"]
          }
        ],
        "sesuo": [
          {
            "sentence": "Mano ___ dirba banke.",
            "translationRu": "Моя сестра работает в банке.",
            "answer": "sesuo",
            "options": ["sesuo", "mama", "teta"]
          },
          {
            "sentence": "Aš laukiu ___.",
            "translationRu": "Я жду сестру.",
            "answer": "sesers",
            "options": ["sesers", "mamos", "tetos"]
          },
          {
            "sentence": "Aš apkabinu ___.",
            "translationRu": "Я обнимаю сестру.",
            "answer": "seserį",
            "options": ["seserį", "mamą", "tetą"]
          }
        ],
        "vaikas": [
          {
            "sentence": "Tas ___ žaidžia kieme.",
            "translationRu": "Этот ребенок играет во дворе.",
            "answer": "vaikas",
            "options": ["vaikas", "kūdikis", "anūkas"]
          },
          {
            "sentence": "Aš matau ___.",
            "translationRu": "Я вижу ребенка.",
            "answer": "vaiką",
            "options": ["vaiką", "kūdikį", "anūką"]
          },
          {
            "sentence": "Mažas ___ juokiasi.",
            "translationRu": "Маленький ребенок смеется.",
            "answer": "vaikas",
            "options": ["vaikas", "kūdikis", "anūkas"]
          }
        ],
        "kudikis": [
          {
            "sentence": "___ miega lopšyje.",
            "translationRu": "Младенец спит в колыбели.",
            "answer": "kūdikis",
            "options": ["kūdikis", "vaikas", "anūkas"]
          },
          {
            "sentence": "Ji maitina ___.",
            "translationRu": "Она кормит младенца.",
            "answer": "kūdikį",
            "options": ["kūdikį", "vaiką", "anūką"]
          },
          {
            "sentence": "Mažas ___ verkia.",
            "translationRu": "Маленький младенец плачет.",
            "answer": "kūdikis",
            "options": ["kūdikis", "vaikas", "anūkas"]
          }
        ],
        "vyras": [
          {
            "sentence": "Mano ___ dirba inžinieriumi.",
            "translationRu": "Мой муж работает инженером.",
            "answer": "vyras",
            "options": ["vyras", "brolis", "tėvas"]
          },
          {
            "sentence": "Aš laukiu ___.",
            "translationRu": "Я жду мужа.",
            "answer": "vyro",
            "options": ["vyro", "brolio", "tėvo"]
          },
          {
            "sentence": "Ji myli savo ___.",
            "translationRu": "Она любит своего мужа.",
            "answer": "vyrą",
            "options": ["vyrą", "brolį", "tėvą"]
          }
        ],
        "zmona": [
          {
            "sentence": "Jo ___ dirba mokytoja.",
            "translationRu": "Его жена работает учительницей.",
            "answer": "žmona",
            "options": ["žmona", "sesuo", "mama"]
          },
          {
            "sentence": "Aš laukiu ___.",
            "translationRu": "Я жду жену.",
            "answer": "žmonos",
            "options": ["žmonos", "sesers", "mamos"]
          },
          {
            "sentence": "Jis myli savo ___.",
            "translationRu": "Он любит свою жену.",
            "answer": "žmoną",
            "options": ["žmoną", "seserį", "mamą"]
          }
        ],
        "senelis": [
          {
            "sentence": "Mano ___ gyvena kaime.",
            "translationRu": "Мой дедушка живет в деревне.",
            "answer": "senelis",
            "options": ["senelis", "tėvas", "dėdė"]
          },
          {
            "sentence": "Aš lankau ___.",
            "translationRu": "Я навещаю дедушку.",
            "answer": "senelį",
            "options": ["senelį", "tėvą", "dėdę"]
          },
          {
            "sentence": "___ pasakoja istorijas.",
            "translationRu": "Дедушка рассказывает истории.",
            "answer": "senelis",
            "options": ["senelis", "tėvas", "dėdė"]
          }
        ],
        "senele": [
          {
            "sentence": "Mano ___ kepa pyragus.",
            "translationRu": "Моя бабушка (нейтр.) печет пироги.",
            "answer": "senelė",
            "options": ["senelė", "močiutė", "teta"]
          },
          {
            "sentence": "Aš lankau ___.",
            "translationRu": "Я навещаю бабушку (нейтр.).",
            "answer": "senelę",
            "options": ["senelę", "tetą", "seserį"]
          },
          {
            "sentence": "Be ___ pasakų man liūdna.",
            "translationRu": "Без сказок бабушки (нейтр.) мне грустно.",
            "answer": "senelės",
            "options": ["senelės", "tetos", "sesers"]
          }
        ],
        "mociute": [
          {
            "sentence": "Mano ___ kepa pyragus.",
            "translationRu": "Моя бабушка (ласк.) печет пироги.",
            "answer": "močiutė",
            "options": ["močiutė", "senelė", "teta"]
          },
          {
            "sentence": "Aš apkabinu ___.",
            "translationRu": "Я обнимаю бабушку (ласк.).",
            "answer": "močiutę",
            "options": ["močiutę", "tetą", "seserį"]
          },
          {
            "sentence": "___ pasakoja pasakas.",
            "translationRu": "Бабушка (ласк.) рассказывает сказки.",
            "answer": "močiutė",
            "options": ["močiutė", "senelė", "teta"]
          }
        ],
        "prosenelis": [
          {
            "sentence": "Mano ___ gyvena kaime.",
            "translationRu": "Мой прадедушка живет в деревне.",
            "answer": "prosenelis",
            "options": ["prosenelis", "senelis", "tėvas"]
          },
          {
            "sentence": "Aš prisimenu ___.",
            "translationRu": "Я помню прадедушку.",
            "answer": "prosenelį",
            "options": ["prosenelį", "senelį", "tėvą"]
          },
          {
            "sentence": "___ yra mokytojas.",
            "translationRu": "Прадедушка — учитель.",
            "answer": "prosenelis",
            "options": ["prosenelis", "senelis", "tėvas"]
          }
        ],
        "prosenele": [
          {
            "sentence": "Mano ___ gyvena mažame name.",
            "translationRu": "Моя прабабушка живет в маленьком доме.",
            "answer": "prosenelė",
            "options": ["prosenelė", "senelė", "teta"]
          },
          {
            "sentence": "Aš prisimenu ___.",
            "translationRu": "Я помню прабабушку.",
            "answer": "prosenelę",
            "options": ["prosenelę", "senelę", "tetą"]
          },
          {
            "sentence": "___ yra siuvėja.",
            "translationRu": "Прабабушка — портниха.",
            "answer": "prosenelė",
            "options": ["prosenelė", "senelė", "teta"]
          }
        ],
        "anukas_anuke": [
          {
            "sentence": "Jų ___ gyvena Londone.",
            "translationRu": "Их внук живет в Лондоне.",
            "answer": "anūkas",
            "options": ["anūkas", "sūnus", "pusbrolis"]
          },
          {
            "sentence": "Močiutė myli ___.",
            "translationRu": "Бабушка любит внука.",
            "answer": "anūką",
            "options": ["anūką", "sūnų", "pusbrolį"]
          },
          {
            "sentence": "Maža ___ piešia.",
            "translationRu": "Маленькая внучка рисует.",
            "answer": "anūkė",
            "options": ["anūkė", "duktė", "pusseserė"]
          }
        ],
        "gimines": [
          {
            "sentence": "Visos ___ susirenka per šventes.",
            "translationRu": "Все родственники собираются на праздники.",
            "answer": "giminės",
            "options": ["giminės", "tėvai", "vaikai"]
          },
          {
            "sentence": "Aš lankau ___.",
            "translationRu": "Я навещаю родственников.",
            "answer": "gimines",
            "options": ["gimines", "tėvus", "vaikus"]
          },
          {
            "sentence": "___ gyvena skirtinguose miestuose.",
            "translationRu": "Родственники живут в разных городах.",
            "answer": "giminės",
            "options": ["giminės", "tėvai", "vaikai"]
          }
        ],
        "dede": [
          {
            "sentence": "Mano ___ gyvena užsienyje.",
            "translationRu": "Мой дядя живет за границей.",
            "answer": "dėdė",
            "options": ["dėdė", "tėvas", "brolis"]
          },
          {
            "sentence": "Aš lankau ___.",
            "translationRu": "Я навещаю дядю.",
            "answer": "dėdę",
            "options": ["dėdę", "tėvą", "brolį"]
          },
          {
            "sentence": "___ atveža dovanų.",
            "translationRu": "Дядя привозит подарки.",
            "answer": "dėdė",
            "options": ["dėdė", "tėvas", "brolis"]
          }
        ],
        "teta": [
          {
            "sentence": "Mano ___ gyvena Kaune.",
            "translationRu": "Моя тётя живет в Каунасе.",
            "answer": "teta",
            "options": ["teta", "mama", "sesuo"]
          },
          {
            "sentence": "Aš lankau ___.",
            "translationRu": "Я навещаю тётю.",
            "answer": "tetą",
            "options": ["tetą", "mamą", "seserį"]
          },
          {
            "sentence": "___ atveža pyragą.",
            "translationRu": "Тётя привозит пирог.",
            "answer": "teta",
            "options": ["teta", "mama", "sesuo"]
          }
        ],
        "pusbrolis": [
          {
            "sentence": "Mano ___ mokosi universitete.",
            "translationRu": "Мой двоюродный брат учится в университете.",
            "answer": "pusbrolis",
            "options": ["pusbrolis", "brolis", "anūkas"]
          },
          {
            "sentence": "Aš matau ___.",
            "translationRu": "Я вижу двоюродного брата.",
            "answer": "pusbrolį",
            "options": ["pusbrolį", "brolį", "anūką"]
          },
          {
            "sentence": "___ žaidžia krepšinį.",
            "translationRu": "Двоюродный брат играет в баскетбол.",
            "answer": "pusbrolis",
            "options": ["pusbrolis", "brolis", "anūkas"]
          }
        ],
        "pussesere": [
          {
            "sentence": "Mano ___ studijuoja.",
            "translationRu": "Моя двоюродная сестра учится.",
            "answer": "pusseserė",
            "options": ["pusseserė", "sesuo", "anūkė"]
          },
          {
            "sentence": "Aš matau ___.",
            "translationRu": "Я вижу двоюродную сестру.",
            "answer": "pusseserę",
            "options": ["pusseserę", "seserį", "anūkę"]
          },
          {
            "sentence": "___ gyvena netoli.",
            "translationRu": "Двоюродная сестра живет рядом.",
            "answer": "pusseserė",
            "options": ["pusseserė", "sesuo", "anūkė"]
          }
        ],
        "vedes": [
          {
            "sentence": "Jonas yra ___.",
            "translationRu": "Йонас женат.",
            "answer": "vedęs",
            "options": ["vedęs", "išsiskyręs", "miręs"]
          },
          {
            "sentence": "Jis jau ___ ir turi šeimą.",
            "translationRu": "Он уже женат и имеет семью.",
            "answer": "vedęs",
            "options": ["vedęs", "išsiskyręs", "miręs"]
          },
          {
            "sentence": "Mano brolis yra ___.",
            "translationRu": "Мой брат женат.",
            "answer": "vedęs",
            "options": ["vedęs", "išsiskyręs", "miręs"]
          }
        ],
        "istekejusi": [
          {
            "sentence": "Ji yra ___.",
            "translationRu": "Она замужем.",
            "answer": "ištekėjusi",
            "options": ["ištekėjusi", "išsiskyrusi", "mirusi"]
          },
          {
            "sentence": "Ji jau ___ ir turi vaikų.",
            "translationRu": "Она уже замужем и имеет детей.",
            "answer": "ištekėjusi",
            "options": ["ištekėjusi", "išsiskyrusi", "mirusi"]
          },
          {
            "sentence": "Mano sesuo yra ___.",
            "translationRu": "Моя сестра замужем.",
            "answer": "ištekėjusi",
            "options": ["ištekėjusi", "išsiskyrusi", "mirusi"]
          }
        ],
        "issiskyres": [
          {
            "sentence": "Jis yra ___.",
            "translationRu": "Он разведен.",
            "answer": "išsiskyręs",
            "options": ["išsiskyręs", "vedęs", "miręs"]
          },
          {
            "sentence": "Mano dėdė yra ___.",
            "translationRu": "Мой дядя разведен.",
            "answer": "išsiskyręs",
            "options": ["išsiskyręs", "vedęs", "miręs"]
          },
          {
            "sentence": "Po skyrybų jis yra ___.",
            "translationRu": "После развода он разведен.",
            "answer": "išsiskyręs",
            "options": ["išsiskyręs", "vedęs", "miręs"]
          }
        ],
        "issiskyrusi": [
          {
            "sentence": "Ji yra ___.",
            "translationRu": "Она разведена.",
            "answer": "išsiskyrusi",
            "options": ["išsiskyrusi", "ištekėjusi", "mirusi"]
          },
          {
            "sentence": "Mano teta yra ___.",
            "translationRu": "Моя тётя разведена.",
            "answer": "išsiskyrusi",
            "options": ["išsiskyrusi", "ištekėjusi", "mirusi"]
          },
          {
            "sentence": "Po skyrybų ji yra ___.",
            "translationRu": "После развода она разведена.",
            "answer": "išsiskyrusi",
            "options": ["išsiskyrusi", "ištekėjusi", "mirusi"]
          }
        ],
        "mires": [
          {
            "sentence": "Senelis yra ___.",
            "translationRu": "Дедушка умер.",
            "answer": "miręs",
            "options": ["miręs", "vedęs", "išsiskyręs"]
          },
          {
            "sentence": "Jis jau ___.",
            "translationRu": "Он уже умер.",
            "answer": "miręs",
            "options": ["miręs", "vedęs", "išsiskyręs"]
          },
          {
            "sentence": "Mano prosenelis yra ___.",
            "translationRu": "Мой прадедушка умер.",
            "answer": "miręs",
            "options": ["miręs", "vedęs", "išsiskyręs"]
          }
        ],
        "mirusi": [
          {
            "sentence": "Močiutė yra ___.",
            "translationRu": "Бабушка умерла.",
            "answer": "mirusi",
            "options": ["mirusi", "ištekėjusi", "išsiskyrusi"]
          },
          {
            "sentence": "Ji jau ___.",
            "translationRu": "Она уже умерла.",
            "answer": "mirusi",
            "options": ["mirusi", "ištekėjusi", "išsiskyrusi"]
          },
          {
            "sentence": "Mano prosenelė yra ___.",
            "translationRu": "Моя прабабушка умерла.",
            "answer": "mirusi",
            "options": ["mirusi", "ištekėjusi", "išsiskyrusi"]
          }
        ]
      };

      const ui = {
        startScreen: document.getElementById("start-screen"),
        testScreen: document.getElementById("test-screen"),
        summaryScreen: document.getElementById("summary-screen"),
        startButton: document.getElementById("start-button"),
        resumeNote: document.getElementById("resume-note"),
        versionNote: document.getElementById("version-note"),
        startNewButton: document.getElementById("start-new-button"),
        restartButton: document.getElementById("restart-button"),
        resetButton: document.getElementById("reset-button"),
        testTitle: document.getElementById("test-title"),

        testProgress: document.getElementById("test-progress"),
        overallProgress: document.getElementById("overall-progress"),
        questionLabel: document.getElementById("question-label"),
        questionText: document.getElementById("question-text"),
        questionSubtitle: document.getElementById("question-subtitle"),
        saveButton: document.getElementById("save-question"),
        answerBlock: document.getElementById("answer-block"),
        feedback: document.getElementById("feedback"),
        nextPanel: document.getElementById("next-panel"),
        nextButton: document.getElementById("next-button"),
        summaryTotal: document.getElementById("summary-total"),
        summaryTable: document.getElementById("summary-table"),
        savedQuestionsSection: document.getElementById("saved-questions-section"),
        savedQuestionsList: document.getElementById("saved-questions-list"),
        savedQuestionsEmpty: document.getElementById("saved-questions-empty"),
        clearSavedQuestionsButton: document.getElementById("clear-saved-questions")
      };

      const shuffle = (array) => {
        const copy = [...array];
        for (let i = copy.length - 1; i > 0; i -= 1) {
          const j = Math.floor(Math.random() * (i + 1));
          [copy[i], copy[j]] = [copy[j], copy[i]];
        }
        return copy;
      };

      const getRandomWords = (excludeId, count, field = "lt") => {
        return shuffle(wordSet.words.filter((item) => item.id !== excludeId))
          .slice(0, count)
          .map((item) => item[field]);
      };

      const normalizeAnswer = (value) => value.trim().toLowerCase().replace(/\s+/g, " ");

      const buildFlashcards = () => {
        const cards = [];
        wordSet.words.forEach((word) => {
          cards.push({
            id: `flash_${word.id}_lt`,
            type: "flashcards",
            prompt: word.lt,
            answer: word.ru,
            label: "Translate to Russian"
          });
          cards.push({
            id: `flash_${word.id}_ru`,
            type: "flashcards",
            prompt: word.ru,
            answer: word.lt,
            label: "Translate to Lithuanian"
          });
        });
        return shuffle(cards);
      };

      const buildMultipleChoice = () => {
        const questions = [];
        wordSet.words.forEach((word) => {
          for (let i = 0; i < 3; i += 1) {
            const wrong = getRandomWords(word.id, 2, "ru");
            const options = shuffle([word.ru, ...wrong]);
            questions.push({
              id: `mc_${word.id}_${i + 1}`,
              type: "multipleChoice",
              prompt: word.lt,
              label: "Choose the correct translation",
              options,
              correct: word.ru
            });
          }
        });
        return shuffle(questions);
      };

      const buildGapFill = () => {
        const questions = [];
        wordSet.words.forEach((word) => {
          const variants = gapFillVariants[word.id] || [];
          variants.forEach((variant, index) => {
            const options = shuffle(Array.from(new Set(variant.options || [variant.answer])));
            questions.push({
              id: `gf_${word.id}_${index + 1}`,
              type: "gapFill",
              prompt: variant.sentence,
              subtitle: variant.translationRu,
              options,
              correct: variant.answer,
              label: "Fill in the blank"
            });
          });
        });
        return shuffle(questions);
      };

      const buildGapFillInput = () => {
        const questions = [];
        wordSet.words.forEach((word) => {
          const variants = gapFillVariants[word.id] || [];
          variants.forEach((variant, index) => {
            questions.push({
              id: `gfi_${word.id}_${index + 1}`,
              type: "gapFillInput",
              prompt: variant.sentence,
              subtitle: variant.translationRu,
              correct: variant.answer,
              label: "Type the missing word"
            });
          });
        });
        return shuffle(questions);
      };

      const testBlueprints = [
        { name: "Flashcards", type: "flashcards", build: buildFlashcards },
        { name: "Multiple Choice", type: "multipleChoice", build: buildMultipleChoice },
        { name: "Gap Fill", type: "gapFill", build: buildGapFill },
        { name: "Gap Fill (Typing)", type: "gapFillInput", build: buildGapFillInput }
      ];

      const QUESTION_TYPE_CHUNK_SIZE = 10;
      const AUTO_ADVANCE_DELAY_MS = 3000;
      const NEXT_BUTTON_LABEL = "Next";
      const TEST_VERSION = "1.0.0";
      const STORAGE_KEY = `lt-test-session:${location.pathname}`;
      const SAVED_QUESTIONS_KEY = `lt-test-saved:${location.pathname}`;
      const REPEAT_MIN_OFFSET = 4;
      const REPEAT_MAX_OFFSET = 6;

      let session = null;

      const resetSession = () => {
        const tests = testBlueprints.map((test) => {
          const questions = test.build().map((question) => ({
            ...question,
            testName: test.name
          }));

          return {
            ...test,
            questions
          };
        });

        const queues = tests.map((test) => ({
          name: test.name,
          type: test.type,
          questions: [...test.questions]
        }));

        const questions = [];
        while (queues.some((queue) => queue.questions.length > 0)) {
          queues.forEach((queue) => {
            questions.push(...queue.questions.splice(0, QUESTION_TYPE_CHUNK_SIZE));
          });
        }

        session = {
          tests,
          questions,
          currentQuestionIndex: 0,
          analytics: {},
          autoAdvanceTimeoutId: null,
          autoAdvanceIntervalId: null,
          repeatCounter: 0
        };

        session.tests.forEach((test) => {
          session.analytics[test.type] = {
            name: test.name,
            correct: 0,
            total: test.questions.length
          };
        });
      };

      const saveSession = () => {
        if (!session) {
          return;
        }

        const payload = {
          version: TEST_VERSION,
          questions: session.questions,
          currentQuestionIndex: session.currentQuestionIndex,
          analytics: session.analytics,
          repeatCounter: session.repeatCounter
        };

        localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));
      };

      const loadSession = () => {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) {
          return { session: null, isOutdated: false };
        }

        try {
          const parsed = JSON.parse(raw);
          if (!parsed || !Array.isArray(parsed.questions) || typeof parsed.currentQuestionIndex !== "number") {
            return { session: null, isOutdated: false };
          }

          const isOutdated = parsed.version !== TEST_VERSION;

          return {
            session: {
              tests: null,
              questions: parsed.questions,
              currentQuestionIndex: Math.min(parsed.currentQuestionIndex, parsed.questions.length),
              analytics: parsed.analytics || {},
              autoAdvanceTimeoutId: null,
              autoAdvanceIntervalId: null,
              repeatCounter: parsed.repeatCounter || 0
            },
            isOutdated
          };
        } catch (error) {
          return { session: null, isOutdated: false };
        }
      };

      const clearSavedSession = () => {
        localStorage.removeItem(STORAGE_KEY);
      };

      const loadSavedQuestions = () => {
        try {
          const raw = localStorage.getItem(SAVED_QUESTIONS_KEY);
          if (!raw) {
            return [];
          }
          const parsed = JSON.parse(raw);
          return Array.isArray(parsed) ? parsed : [];
        } catch (error) {
          return [];
        }
      };

      const persistSavedQuestions = (items) => {
        localStorage.setItem(SAVED_QUESTIONS_KEY, JSON.stringify(items));
      };

      const buildSavedQuestion = (question) => {
        const id = question.repeatOf || question.id;
        return {
          id,
          type: question.type,
          label: question.label || "",
          testName: question.testName || "",
          prompt: question.prompt || "",
          subtitle: question.subtitle || "",
          answer: question.correct ?? question.answer ?? ""
        };
      };

      const updateSaveButton = (question) => {
        if (!ui.saveButton) {
          return;
        }
        const saved = loadSavedQuestions();
        const questionId = question ? (question.repeatOf || question.id) : null;
        const isSaved = questionId ? saved.some((item) => item.id === questionId) : false;
        ui.saveButton.setAttribute("aria-pressed", isSaved ? "true" : "false");
        ui.saveButton.classList.toggle("text-emerald-600", isSaved);
        ui.saveButton.classList.toggle("border-emerald-200", isSaved);
        ui.saveButton.title = isSaved ? "Saved" : "Save question";
      };

      const toggleSavedQuestion = () => {
        const question = currentQuestion();
        if (!question) {
          return;
        }
        const saved = loadSavedQuestions();
        const questionId = question.repeatOf || question.id;
        const existingIndex = saved.findIndex((item) => item.id === questionId);
        if (existingIndex >= 0) {
          saved.splice(existingIndex, 1);
        } else {
          saved.push(buildSavedQuestion(question));
        }
        persistSavedQuestions(saved);
        updateSaveButton(question);
      };

      const renderSavedQuestions = () => {
        if (!ui.savedQuestionsList || !ui.savedQuestionsEmpty) {
          return;
        }
        const saved = loadSavedQuestions();
        ui.savedQuestionsList.innerHTML = "";
        if (!saved.length) {
          ui.savedQuestionsEmpty.classList.remove("hidden");
          return;
        }
        ui.savedQuestionsEmpty.classList.add("hidden");
        saved.forEach((item) => {
          const card = document.createElement("div");
          card.className = "rounded-xl border border-slate-100 bg-slate-50 px-4 py-3 text-sm text-slate-700";
          card.innerHTML = `
            <div class="flex flex-wrap items-center justify-between gap-2">
              <p class="font-semibold text-slate-800">${item.label || item.testName || "Saved question"}</p>
              <p class="text-xs text-slate-500">${item.type}</p>
            </div>
            <p class="mt-2 font-semibold">${item.prompt}</p>
            ${item.subtitle ? `<p class="mt-1 text-xs text-slate-500">${item.subtitle}</p>` : ""}
            <p class="mt-2 text-xs text-slate-500">Answer: <span class="font-semibold text-slate-700">${item.answer}</span></p>
          `;
          ui.savedQuestionsList.appendChild(card);
        });
      };

      const clearSavedQuestions = () => {
        localStorage.removeItem(SAVED_QUESTIONS_KEY);
        renderSavedQuestions();
        updateSaveButton(currentQuestion());
      };

      const updateStartScreen = () => {
        const saved = loadSession();
        const hasSaved = Boolean(saved.session);
        const showOutdated = hasSaved && saved.isOutdated;

        ui.startButton.textContent = hasSaved ? "Continue Test" : "Start Tests";
        ui.resumeNote.classList.toggle("hidden", !hasSaved);
        ui.versionNote.classList.toggle("hidden", !showOutdated);
        ui.startNewButton.classList.toggle("hidden", !showOutdated);
      };

      const showScreen = (screen) => {
        ui.startScreen.classList.add("hidden");
        ui.testScreen.classList.add("hidden");
        ui.summaryScreen.classList.add("hidden");
        screen.classList.remove("hidden");
      };

      const currentQuestion = () => session.questions[session.currentQuestionIndex];

      const getOverallProgress = () => {
        const totals = session.questions.length;
        const answered = session.currentQuestionIndex;
        return `${answered} / ${totals}`;
      };

      const clearFeedback = () => {
        ui.feedback.className = "mt-4 hidden rounded-xl border px-4 py-3 text-sm";
        ui.feedback.textContent = "";
      };

      const showFeedback = (message, isCorrect) => {
        ui.feedback.className = `mt-4 rounded-xl border px-4 py-3 text-sm ${
          isCorrect ? "border-emerald-200 bg-emerald-50 text-emerald-700" : "border-rose-200 bg-rose-50 text-rose-700"
        }`;
        ui.feedback.textContent = message;
      };

      const hideNextButton = () => {
        ui.nextButton.classList.add("hidden");
        ui.nextPanel.classList.add("hidden");
      };

      const showNextButton = () => {
        setNextButtonLabel();
        ui.nextButton.classList.remove("hidden");
        ui.nextPanel.classList.remove("hidden");
      };

      const setNextButtonLabel = (label = NEXT_BUTTON_LABEL) => {
        ui.nextButton.textContent = label;
      };

      const clearAutoAdvance = () => {
        if (!session || (session.autoAdvanceTimeoutId === null && session.autoAdvanceIntervalId === null)) {
          return;
        }

        if (session.autoAdvanceTimeoutId !== null) {
          clearTimeout(session.autoAdvanceTimeoutId);
          session.autoAdvanceTimeoutId = null;
        }

        if (session.autoAdvanceIntervalId !== null) {
          clearInterval(session.autoAdvanceIntervalId);
          session.autoAdvanceIntervalId = null;
        }

        setNextButtonLabel();
      };

      const scheduleAutoAdvance = () => {
        clearAutoAdvance();

        let remainingSeconds = Math.ceil(AUTO_ADVANCE_DELAY_MS / 1000);
        setNextButtonLabel(`${NEXT_BUTTON_LABEL} (${remainingSeconds})`);

        session.autoAdvanceIntervalId = setInterval(() => {
          remainingSeconds -= 1;
          if (remainingSeconds > 0) {
            setNextButtonLabel(`${NEXT_BUTTON_LABEL} (${remainingSeconds})`);
          }
        }, 1000);

        session.autoAdvanceTimeoutId = setTimeout(() => {
          session.autoAdvanceTimeoutId = null;
          goToNext();
        }, AUTO_ADVANCE_DELAY_MS);
      };

      const enqueueRepeatQuestion = (question) => {
        if (!session) {
          return;
        }

        const offset =
          Math.floor(Math.random() * (REPEAT_MAX_OFFSET - REPEAT_MIN_OFFSET + 1)) + REPEAT_MIN_OFFSET;
        const insertIndex = Math.min(session.currentQuestionIndex + offset, session.questions.length);
        session.repeatCounter += 1;

        const repeatQuestion = {
          ...question,
          id: `${question.id}_repeat_${session.repeatCounter}`,
          repeatOf: question.repeatOf || question.id
        };

        session.questions.splice(insertIndex, 0, repeatQuestion);
        if (session.analytics[question.type]) {
          session.analytics[question.type].total += 1;
        }
      };

      const renderOptions = (question) => {
        ui.answerBlock.innerHTML = "";

        if (question.type === "flashcards") {
          const answerText = document.createElement("div");
          answerText.className = "hidden rounded-xl bg-slate-100 px-4 py-3 text-sm text-slate-700";
          answerText.textContent = `Answer: ${question.answer}`;

          const actions = document.createElement("div");
          actions.className = "mt-2 grid grid-cols-1 gap-3 sm:grid-cols-2";

          const knowButton = document.createElement("button");
          knowButton.textContent = "Know";
          knowButton.className =
            "rounded-xl bg-emerald-600 px-4 py-3 text-sm font-semibold text-white shadow-sm transition hover:bg-emerald-500 disabled:opacity-50";

          const dontKnowButton = document.createElement("button");
          dontKnowButton.textContent = "Don’t know";
          dontKnowButton.className =
            "rounded-xl bg-rose-600 px-4 py-3 text-sm font-semibold text-white shadow-sm transition hover:bg-rose-500 disabled:opacity-50";

          const handleAnswer = (isCorrect) => {
            session.analytics.flashcards.correct += isCorrect ? 1 : 0;
            if (isCorrect) {
              goToNext();
              return;
            }

            answerText.classList.remove("hidden");
            clearFeedback();
            knowButton.disabled = true;
            dontKnowButton.disabled = true;
            enqueueRepeatQuestion(question);
            showNextButton();
            saveSession();
          };

          knowButton.addEventListener("click", () => handleAnswer(true));
          dontKnowButton.addEventListener("click", () => handleAnswer(false));

          ui.answerBlock.append(answerText, actions);
          actions.append(knowButton, dontKnowButton);
          return;
        }

        if (question.type === "gapFillInput") {
          const wrapper = document.createElement("div");
          wrapper.className = "space-y-3";

          const input = document.createElement("input");
          input.type = "text";
          input.autocomplete = "off";
          input.className =
            "w-full rounded-xl border border-slate-200 px-4 py-3 text-sm text-slate-700 shadow-sm focus:border-indigo-400 focus:outline-none focus:ring-2 focus:ring-indigo-100 disabled:bg-slate-50";
          input.placeholder = "Type your answer";

          const submit = document.createElement("button");
          submit.textContent = "Check answer";
          submit.className =
            "w-full rounded-xl bg-indigo-600 px-4 py-3 text-sm font-semibold text-white shadow-sm transition hover:bg-indigo-500 disabled:opacity-50";

          const handleSubmit = () => {
            if (submit.disabled) {
              return;
            }

            const rawValue = input.value.trim();
            if (!rawValue) {
              showFeedback("Type your answer first.", false);
              return;
            }

            const isCorrect =
              normalizeAnswer(rawValue) === normalizeAnswer(question.correct);
            session.analytics[question.type].correct += isCorrect ? 1 : 0;

            input.disabled = true;
            submit.disabled = true;

            showFeedback(
              isCorrect ? "Correct!" : `Not correct. The right answer is “${question.correct}”.`,
              isCorrect
            );
            if (!isCorrect) {
              enqueueRepeatQuestion(question);
            }
            showNextButton();
            saveSession();
            if (isCorrect) {
              scheduleAutoAdvance();
            }
          };

          submit.addEventListener("click", handleSubmit);
          input.addEventListener("keydown", (event) => {
            if (event.key === "Enter") {
              handleSubmit();
            }
          });

          wrapper.append(input, submit);
          ui.answerBlock.appendChild(wrapper);
          input.focus();
          return;
        }

        const optionsWrapper = document.createElement("div");
        optionsWrapper.className = "grid gap-3";

        question.options.forEach((option) => {
          const button = document.createElement("button");
          button.textContent = option;
          button.className =
            "w-full rounded-xl border border-slate-200 px-4 py-3 text-left text-sm font-semibold text-slate-700 transition hover:bg-slate-50";

          button.addEventListener("click", () => {
            const isCorrect = option === question.correct;
            session.analytics[question.type].correct += isCorrect ? 1 : 0;

            optionsWrapper.querySelectorAll("button").forEach((child) => {
              child.disabled = true;
              if (child.textContent === question.correct) {
                child.classList.add("border-emerald-400", "bg-emerald-50");
              } else if (child.textContent === option && !isCorrect) {
                child.classList.add("border-rose-300", "bg-rose-50");
              }
            });

            showFeedback(
              isCorrect ? "Correct!" : `Not correct. The right answer is “${question.correct}”.`,
              isCorrect
            );
            if (!isCorrect) {
              enqueueRepeatQuestion(question);
            }
            showNextButton();
            saveSession();
            if (isCorrect) {
              scheduleAutoAdvance();
            }
          });

          optionsWrapper.appendChild(button);
        });

        ui.answerBlock.appendChild(optionsWrapper);
      };

      const renderQuestion = () => {
        const question = currentQuestion();

        clearAutoAdvance();

        ui.testTitle.textContent = question.testName || "";
        ui.testProgress.textContent = `Question ${session.currentQuestionIndex + 1} of ${session.questions.length}`;
        ui.overallProgress.textContent = getOverallProgress();
        ui.questionLabel.textContent = question.label;
        ui.questionText.textContent = question.prompt;
        ui.questionSubtitle.textContent = question.subtitle || "";
        ui.questionSubtitle.classList.toggle("hidden", !question.subtitle);
        updateSaveButton(question);

        hideNextButton();
        clearFeedback();
        renderOptions(question);
      };

      const goToNext = () => {
        clearAutoAdvance();

        if (session.currentQuestionIndex < session.questions.length - 1) {
          session.currentQuestionIndex += 1;
          saveSession();
          renderQuestion();
          return;
        }

        renderSummary();
      };

      const renderSummary = () => {
        clearAutoAdvance();
        hideNextButton();
        showScreen(ui.summaryScreen);
        clearSavedSession();
        updateStartScreen();
        const totals = Object.values(session.analytics).reduce(
          (acc, item) => {
            acc.correct += item.correct;
            acc.total += item.total;
            return acc;
          },
          { correct: 0, total: 0 }
        );

        const accuracy = totals.total === 0 ? 0 : Math.round((totals.correct / totals.total) * 100);
        ui.summaryTotal.textContent = `Overall accuracy: ${accuracy}% (${totals.correct} of ${totals.total})`;
        ui.summaryTable.innerHTML = "";

        Object.values(session.analytics).forEach((item) => {
          const row = document.createElement("div");
          row.className = "flex items-center justify-between rounded-xl border border-slate-100 bg-slate-50 px-4 py-3 text-sm";
          row.innerHTML = `
            <div>
              <p class="font-semibold text-slate-700">${item.name}</p>
              <p class="text-xs text-slate-500">${item.correct} correct of ${item.total}</p>
            </div>
            <p class="text-sm font-semibold text-slate-700">${Math.round((item.correct / item.total) * 100)}%</p>
          `;
          ui.summaryTable.appendChild(row);
        });

        renderSavedQuestions();
      };

      const startTests = (options = {}) => {
        const { forceNew = false } = options;

        if (forceNew) {
          clearSavedSession();
          resetSession();
        } else {
          const saved = loadSession();
          session = saved.session || null;
          if (!session || !session.questions.length) {
            resetSession();
          }
        }

        showScreen(ui.testScreen);
        renderQuestion();
        saveSession();
        updateStartScreen();
      };

      updateStartScreen();
      ui.startButton.addEventListener("click", () => startTests());
      ui.startNewButton.addEventListener("click", () => startTests({ forceNew: true }));
      ui.restartButton.addEventListener("click", () => startTests({ forceNew: true }));
      ui.resetButton.addEventListener("click", () => startTests({ forceNew: true }));
      ui.nextButton.addEventListener("click", goToNext);
      if (ui.saveButton) {
        ui.saveButton.addEventListener("click", toggleSavedQuestion);
      }
      if (ui.clearSavedQuestionsButton) {
        ui.clearSavedQuestionsButton.addEventListener("click", clearSavedQuestions);
      }
    </script>
  </body>
</html>
